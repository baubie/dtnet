
#include "gri++.h"

using namespace std;


bool Gri::verifyData(Gri::Plot &plot)
{
    vector<vector<double> >::iterator iter;
    for (iter = plot.y.begin(); iter != plot.y.end(); ++iter)
    {
        if (iter->size() != plot.x.size())
        {
            cout << "[Gri++] Error: x and y vector sizes do not all match!" << endl;
            return false;
        }
    }
    return true;
}

Gri::PanelID Gri::plot(vector<double> const &x, vector<double> const &y, Gri::PlotProperties properties)
{
    return this->plot(x, y, properties, Gri::NEW_PANEL);
}

Gri::PanelID Gri::plot(vector<double> const &x, vector<vector<double> > const &y, Gri::PlotProperties properties)
{
    return this->plot(x, y, properties, Gri::NEW_PANEL);
}

Gri::PanelID Gri::plot(vector<double> const &x, vector<vector<double> > const &y, Gri::PlotProperties properties, Gri::PanelID ID)
{
    Gri::Plot plot;
    plot.x = x;
    plot.y = y;
    plot.properties = properties;
    this->verifyData(plot);

    Panel panel;

    if (ID == Gri::NEW_PANEL) 
    {
        // Get a new ID
        this->panels.push_back(panel);
        ID = this->panels.size() - 1;
    }
    else
    {
        try
        {
            panel = this->panels.at(ID);
        } 
        catch (out_of_range outOfRange)
        {
            cout << "[Gri++] Attempted to add to a non-existent panel (" << outOfRange.what() << ")." << endl;
            return false;
        }
        
    }

    panel.plots.push_back(plot);
    this->panels.at(ID) = panel;

    return true;
}


Gri::PanelID Gri::plot(vector<double> const &x, vector<double> const &y, Gri::PlotProperties properties, Gri::PanelID ID)
{
    vector<vector<double> > tmp;
    tmp.push_back(y);
    return this->plot(x, tmp, properties, ID);
}

bool Gri::draw()
{
    return this->draw("output.ps");
}

bool Gri::draw(string const &filename)
{
    string data_file = this->data_to_file();
    string griscript_file = this->griscript_to_file(data_file, filename);

    size_t MAX_BUFFER = 255;
    string command = string("gri ") + griscript_file;
    string gri_output;
    FILE *stream;
    char buffer[MAX_BUFFER];

    stream = popen(command.c_str(), "r");
    while( fgets(buffer, MAX_BUFFER, stream) != NULL ) cout << "[Gri++.output] " << buffer;
    pclose(stream);
    cout << "[Gri++] Saved plot to " << filename << endl;

    // TODO: Delete Temporary Files

    return true;
}

string Gri::data_to_file()
{
    char data_filename[] = "/tmp/gri_data_XXXXXX";
    int pTemp = mkstemp(data_filename);
    boost::iostreams::file_descriptor_sink sink( pTemp );
    boost::iostreams::stream<boost::iostreams::file_descriptor_sink> of( sink );

    if (!of) 
    {
       cout << "[Gri++] Unable to create temporary file." << endl;
       return false;
    }

    vector<Panel>::iterator panel_iter;
    vector<Plot>::iterator plot_iter;
    vector<double>::iterator x_iter;
    vector<double>::iterator y_iter;
    vector<vector<double> >::iterator all_y_iter;

    for( panel_iter = this->panels.begin(); panel_iter != this->panels.end(); ++panel_iter) 
    {
        for ( plot_iter = panel_iter->plots.begin(); plot_iter != panel_iter->plots.end(); ++plot_iter)
        {
            for ( all_y_iter = plot_iter->y.begin(); all_y_iter != plot_iter->y.end(); ++all_y_iter)
            {
                x_iter = plot_iter->x.begin(); // We assume x and y are the same size since verifyData() returned true.
                for ( y_iter = all_y_iter->begin(); y_iter != all_y_iter->end(); ++y_iter)
                {
                    of << fixed
                       << setprecision(3)
                       << *x_iter << "\t" << *y_iter 
                       << endl;
                    ++x_iter;
                }
                of << endl; // Blank line marks a new dataset
            }    
        }
    }
    close ( pTemp );
    return string(data_filename);
}

string Gri::griscript_to_file(string const &data_file, string const &output_file)
{
    char filename[] = "/tmp/gri_script_XXXXXX";
    int pTemp = mkstemp(filename);
    boost::iostreams::file_descriptor_sink sink( pTemp );
    boost::iostreams::stream<boost::iostreams::file_descriptor_sink> of( sink );

    vector<Panel>::iterator panel_iter;
    vector<Plot>::iterator plot_iter;
    vector<vector<double> >::iterator y_iter;
    Color color;
    Color diff;

    of << "######################" << endl;
    of << "# Generated by dtnet #" << endl;
    of << "######################" << endl << endl;

    of << "set postscript filename " << output_file << endl;
    of << "open " << data_file << endl << endl;

    if (this->canvasProperties.auto_layout)
    {
        float panel_width, panel_height;
        int rows;
        int count = 0;
        panel_width = (float)( this->canvasProperties.width / (this->canvasProperties.columns) );
        rows = ceil( this->panels.size() / this->canvasProperties.columns );
        panel_height = (float)( this->canvasProperties.height / rows );

        panel_iter = this->panels.begin();
        for ( int r = 1; r <= rows; ++r )
        {
            for ( int c = 1; c <= this->canvasProperties.columns; ++c )
            {
                
                count++;
                of << "###########" << endl;
                of << "# PANEL " << count << " #" << endl;
                of << "###########" << endl;
            
                of << "set x size " << panel_width << endl;
                of << "set y size " << panel_height << endl;
                of << "set x margin " << (this->canvasProperties.margin_left*c + (c-1)*panel_width) << endl;
                of << "set y margin " << (this->canvasProperties.margin_top*r + (r-1)*panel_height) << endl;
                of << "set x name \"" << panel_iter->properties.x_title << "\"" << endl;
                of << "set y name \"" << panel_iter->properties.y_title << "\"" << endl;
                of << "draw title \"" << panel_iter->properties.title << "\"" << endl;

                for ( plot_iter = panel_iter->plots.begin(); plot_iter != panel_iter->plots.end(); ++plot_iter)
                {
                    diff.r = (plot_iter->properties.last.r - plot_iter->properties.first.r) / plot_iter->y.size();
                    diff.g = (plot_iter->properties.last.g - plot_iter->properties.first.g) / plot_iter->y.size();
                    diff.b = (plot_iter->properties.last.b - plot_iter->properties.first.b) / plot_iter->y.size();
                    color = plot_iter->properties.first;
                    for ( y_iter = plot_iter->y.begin(); y_iter != plot_iter->y.end(); ++y_iter)
                    {
                        of << "read columns x y" << endl;
                        of << "set color rgb " << color.r << " " << color.g << " " << color.b << endl;
                        of << "set font color rgb 0 0 0" << endl;
                        of << "draw curve" << endl;
                        color.r += diff.r;
                        color.g += diff.g;
                        color.b += diff.b;
                    }
                }

                ++panel_iter;
                if (panel_iter == this->panels.end()) { c = this->canvasProperties.columns + 1; r = rows + 1; }
            }
        }
    }

    of << "close" << endl;
    of << "quit" << endl;

    close ( pTemp );

    string old_filename = string(filename);
    string new_filename = string(filename) + ".gri";
    rename(old_filename.c_str(), new_filename.c_str());
    return new_filename; 
}
